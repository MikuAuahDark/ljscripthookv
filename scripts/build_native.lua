-- Script to build native.lua

local arg = {...}
local natives = assert(io.open(assert(arg[1], "need input path"), "rb"))

local objectType = {
	"Any",
	"Hash",
	"Entity",
	"Player",
	"FireId",
	"Ped",
	"Vehicle",
	"Cam",
	"CarGenerator",
	"Group",
	"Train",
	"Pickup",
	"Object",
	"Weapon",
	"Interior",
	"Blip",
	"Texture",
	"TextureDict",
	"CoverPoint",
	"Camera",
	"TaskSequence",
	"ColourIndex",
	"Sphere",
	"ScrHandle"
}
local reserved = {
	"and", "break", "do", "else", "elseif",
	"end", "false", "for", "function", "if",
	"in", "local", "nil", "not", "or",
	"repeat", "return", "then", "true", "until", "while",
	-- Script-specific reserved
	"ffi", "ScriptHookV", "union"
}

io.write("-- This file is automatically generated by build_native.lua\n")
io.write("-- Generated at ", os.date("!%d/%m/%Y %H:%M:%S UTC\n\n"))
io.write [=[
local ffi = require("ffi")
local ScriptHookV = ffi.load("ScriptHookV")

ffi.cdef[[
]=]

-- Generate object types
for _, v in ipairs(objectType) do
	io.write("typedef struct ", v, " {\n\tint id;\n} ", v, ";\n\n")
end

io.write [=[
typedef struct Vector3
{
	float x __attribute__((aligned(8)));
	float y __attribute__((aligned(8)));
	float z __attribute__((aligned(8)));
} Vector3;
]]

local union = ffi.new([[
union {
	uint64_t value;

	bool b;
	int i;
	float f;
	const void *ptr;
	Vector3 *vector3;

]=]

-- Generate object types
for _, v in ipairs(objectType) do
	io.write("\t", v, " ", v:lower(), ";\n")
end
io.write [=[}]])

]=]

local function contains(t, v)
	for i, a in ipairs(t) do
		if a == v then
			return i
		end
	end

	return nil
end

local function parseFunction(namespace, line)
	local ret, name, params, hash = line:match("static (%S+) ([0-9A-Zx_]+)%(([^%)]*)%) {%s*[return]* invoke%b<>%((0x[0-9A-F]+)")
	assert(ret, line)

	local args = {}
	local funcArgs = {}
	local funcArgsSimple = {}
	local retVals = {}
	-- Split args
	for w in params:gmatch("[^,]+") do
		local dataType, argName = w:match("(%w+%*?) ([0-9A-Za-z_]+)")
		assert(dataType, line)
		local isPointer = dataType:sub(-1) == "*"

		if contains(reserved, argName) then
			argName = "r_"..argName
		end

		local t = {
			type = dataType,
			name = argName,
			pointer = isPointer
		}
		args[#args + 1] = t

		if isPointer or name == "Vector3" or ret == "Vector3" then
			-- TODO
			retVals[#retVals + 1] = t
			io.stderr:write("Skipping ", namespace, ".", name, "\n")
			return
		else
			funcArgs[#funcArgs + 1] = t
			funcArgsSimple[#funcArgsSimple + 1] = argName
		end
	end

	-- Write function signature
	io.write("function ", namespace, ".", name, "(", table.concat(funcArgsSimple, ", "), ")\n")

	-- ScriptHookV.nativeInit(hash)
	io.write("\tScriptHookV.nativeInit(", hash, "ULL)\n")

	-- Function body
	for _, v in ipairs(args) do

		-- Is object type?
		if contains(objectType, v.type) then
			-- union.<typelower> = arg
			io.write("\tunion.", v.type:lower(), " = ", v.name, "\n")
			-- ScriptHookV.nativePush64(union.value)
			io.write("\tScriptHookV.nativePush64(union.value)\n")
		-- Is string?
		elseif v.type == "char*" then
			-- union.ptr = arg
			io.write("\tunion.ptr = ", v.name, "\n")
			-- ScriptHookV.nativePush64(union.value)
			io.write("\tScriptHookV.nativePush64(union.value)\n")
		-- Is float?
		elseif v.type == "float" then
			-- union.f = arg
			io.write("\tunion.f = ", v.name, "\n")
			-- ScriptHookV.nativePush64(union.value)
			io.write("\tScriptHookV.nativePush64(union.value)\n")
		-- Is int?
		elseif v.type == "int" then
			-- union.i = arg
			io.write("\tunion.i = ", v.name, "\n")
			-- ScriptHookV.nativePush64(union.value)
			io.write("\tScriptHookV.nativePush64(union.value)\n")
		-- Is boolean?
		elseif v.type == "BOOL" then
			-- union.b = arg
			io.write("\tunion.b = ", v.name, "\n")
			-- ScriptHookV.nativePush64(union.value)
			io.write("\tScriptHookV.nativePush64(union.value)\n")
		else
			-- error("FIXME: <type> <name>")
			io.write("\terror(\"FIXME: ", v.type, " ", v.name, "\")\n")
			break
		end
	end

	if ret == "void" or ret == "Void" then
		-- ScriptHookV.nativeCall()
		io.write("\tScriptHookV.nativeCall()\n")
	else
		-- union.value = ScriptHookV.nativeCall()[0]; [0] because it's pointer
		io.write("\tunion.value = ScriptHookV.nativeCall()[0]\n")

		-- Is object type?
		if contains(objectType, ret) then
			-- return ffi.new("<type>", union.<type>)
			io.write("\treturn ffi.new(\"", ret, "\", union.", ret:lower(), ")\n")
		-- Is string?
		elseif ret == "char*" then
			-- return ffi.string(union.ptr)
			io.write("\treturn ffi.string(union.ptr)\n")
		-- Is float?
		elseif ret == "float" then
			-- return union.f
			io.write("\treturn union.f\n")
		-- Is int?
		elseif ret == "int" then
			-- return union.i
			io.write("\treturn union.i\n")
		-- Is boolean?
		elseif ret == "BOOL" then
			-- return union.i ~= 0
			io.write("\treturn union.i ~= 0\n")
		else
			-- FIXME: return <type>
			io.write("\terror(\"FIXME: return ", ret, "\")\n")
		end
	end

	io.write("end\n\n")
end

-- Read definitions
local currentNamespace = nil
for line in natives:lines() do
	line = line:gsub("\r\n", ""):gsub("\n", ""):gsub("\r", "")

	if line:find("namespace", 1, true) == 1 then
		currentNamespace = line:sub(11)

		-- Decorate namespace
		local dups = string.rep("-", 13 + #currentNamespace + 3)
		io.write(dups, "\n")
		io.write("-- NAMESPACE ", currentNamespace, " --\n")
		io.write(dups, "\n")
		io.write(currentNamespace, " = {}\n")
	elseif currentNamespace then
		if line == "}" then
			currentNamespace = nil
			io.write("\n")
		elseif line ~= "{" then
			parseFunction(currentNamespace, line)
		end
	end
end
