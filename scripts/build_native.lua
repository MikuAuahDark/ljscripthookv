-- Script to build native.lua

local arg = {...}
local natives = assert(io.open(assert(arg[1], "need input path"), "rb"))

local objectType = {
	"Any",
	"Hash",
	"Entity",
	"Player",
	"FireId",
	"Ped",
	"Vehicle",
	"Cam",
	"CarGenerator",
	"Group",
	"Train",
	"Pickup",
	"Object",
	"Weapon",
	"Interior",
	"Blip",
	"Texture",
	"TextureDict",
	"CoverPoint",
	"Camera",
	"TaskSequence",
	"ColourIndex",
	"Sphere",
	"ScrHandle"
}

local reserved = {
	"and", "break", "do", "else", "elseif",
	"end", "false", "for", "function", "if",
	"in", "local", "nil", "not", "or",
	"repeat", "return", "then", "true", "until", "while",
	-- Script-specific reserved
	"ffi", "ScriptHookV", "union", "vectors", "ints", "floats"
}

-- Blacklisted functions, have their own implementation
local blacklist = {
	-- Vector3* in argument is return type
	"GAMEPLAY.FIND_SPAWN_POINT_IN_DIRECTION",
	-- Vector3* in argument is return type
	"GAMEPLAY.GET_MODEL_DIMENSIONS",
	-- Unnecessary
	"GAMEPLAY.SET_BIT",
	-- Unnecessary
	"GAMEPLAY.CLEAR_BIT",
	-- Unnecessary
	"GAMEPLAY.IS_BIT_SET",
	-- Unnecessary
	"GAMEPLAY.IS_STRING_NULL",
	-- Unnecessary
	"GAMEPLAY.IS_STRING_NULL_OR_EMPTY",
	-- Unnecessary
	"GAMEPLAY.STRING_TO_INT",
	-- Vector3* in argument is return type
	"WEAPON.GET_PED_LAST_WEAPON_IMPACT_COORD",
	-- Vector3* in argument is return type
	"MOBILE.GET_MOBILE_PHONE_ROTATION",
	-- Vector3* in argument is return type
	"MOBILE.GET_MOBILE_PHONE_POSITION",
}

io.write("-- This file is automatically generated by build_native.lua\n")
io.write("-- Generated at ", os.date("!%d/%m/%Y %H:%M:%S UTC\n\n"))
io.write [=[
local ffi = require("ffi")
local ScriptHookV = ffi.load("ScriptHookV")

ffi.cdef[[
]=]

-- Generate object types
for _, v in ipairs(objectType) do
	io.write("typedef struct ", v, " {\n\tint id;\n} ", v, ";\n\n")
end

io.write [=[
typedef struct Vector3
{
	float x __attribute__((aligned(8)));
	float y __attribute__((aligned(8)));
	float z __attribute__((aligned(8)));
} Vector3;

typedef union ScriptHookVObject
{
]=]

-- Generate object types
for _, v in ipairs(objectType) do
	io.write("\t", v, " ", v:lower(), ";\n")
end

io.write[=[
} ScriptHookVObject;
]]

local union = ffi.new([[union {
	// Actual value
	uint64_t value;

	// Native types
	bool b;
	int i;
	float f;
	const void *ptr;
	Vector3 *vector3;

	// Objects
	ScriptHookVObject object;
}]])

local vectors = ffi.new("Vector3[16]")
local ints = ffi.new("int[16]")
local floats = ffi.new("float[16]")
local objects = ffi.new("ScriptHookVObject[16]")

]=]

local function contains(t, v)
	for i, a in ipairs(t) do
		if a == v then
			return i
		end
	end

	return nil
end

local function parseFunction(namespace, line)
	local ret, name, params, hash = line:match("static (%S+) ([0-9A-Zx_]+)%(([^%)]*)%) {%s*[return]* invoke%b<>%((0x[0-9A-F]+)")
	assert(ret, line)

	if contains(blacklist, namespace.."."..name) then
		io.stderr:write("Blacklisted ", namespace, ".", name, "\n")
		return
	end

	local args = {}
	local funcArgs = {}
	local funcArgsSimple = {}
	local retVals = {}
	local vectorIndex = 0
	local intIndex = 0
	local floatIndex = 0
	local getFunc = name:find("GET", 1, true)
	getFunc = getFunc == 1 or getFunc == 2

	-- Split args
	for w in params:gmatch("[^,]+") do
		local dataType, ptr, argName = w:match("(%w+)(%*?) ([0-9A-Za-z_]+)")
		assert(dataType, line)

		local isPointer = #ptr == 1
		local outParam = isPointer and (argName:find("out", 1, true) == 1 or getFunc)

		if contains(reserved, argName) then
			argName = "r_"..argName
		end

		local t = {
			type = dataType,
			name = argName,
			pointer = isPointer,
			out = outParam
		}
		args[#args + 1] = t

		if isPointer then
			if dataType == "Vector3" then
				assert(vectorIndex < 16, "increase vector limit size!")
				t.index = vectorIndex
				vectorIndex = vectorIndex + 1
			elseif outParam and dataType == "int" then
				assert(intIndex < 16, "increase int limit size!")
				t.index = intIndex
				intIndex = intIndex + 1
			elseif outParam and dataType == "float" then
				assert(floatIndex < 16, "increase float limit size!")
				t.index = floatIndex
				floatIndex = floatIndex + 1
			elseif dataType ~= "char" and not(contains(objectType, dataType)) then
				-- TODO
				io.stderr:write("Skipping ", namespace, ".", name, "\n")
				return
			end
		end

		if dataType == "Vector3" and isPointer == false then
			-- TODO
			io.stderr:write("FIXME Vector3 non ptr ", namespace, ".", name, "\n")
			return
		--[[
		elseif contains(objectType, dataType) and isPointer == false then
			-- TODO
			io.stderr:write("FIXME ", dataType, " non ptr ", namespace, ".", name, "\n")
			return
		]]
		elseif not(t.out) then
			funcArgs[#funcArgs + 1] = t
			funcArgsSimple[#funcArgsSimple + 1] = argName
		else
			retVals[#retVals + 1] = t
		end
	end

	-- Write function signature
	io.write("function ", namespace, ".", name, "(", table.concat(funcArgsSimple, ", "), ")\n")

	-- ScriptHookV.nativeInit(hash)
	io.write("\tScriptHookV.nativeInit(", hash, "ULL)\n")

	-- Function body
	for _, v in ipairs(args) do
		-- Is object type?
		if contains(objectType, v.type) then
			-- union.object.<typelower> = arg
			io.write("\tunion.object.", v.type:lower(), " = ", v.name, "\n")
			-- ScriptHookV.nativePush64(union.value)
			io.write("\tScriptHookV.nativePush64(union.value)\n")
		-- Is string?
		elseif v.type == "char" and v.pointer then
			-- union.ptr = arg
			io.write("\tunion.ptr = ", v.name, "\n")
			-- ScriptHookV.nativePush64(union.value)
			io.write("\tScriptHookV.nativePush64(union.value)\n")
		-- Is float?
		elseif v.type == "float" then
			if v.pointer and v.out then
				-- union.ptr = floats + <index>
				io.write("\tunion.ptr = floats + ", v.index, "\n")
			else
				-- union.f = arg
				io.write("\tunion.f = ", v.name, "\n")
			end

			-- ScriptHookV.nativePush64(union.value)
			io.write("\tScriptHookV.nativePush64(union.value)\n")
		-- Is int?
		elseif v.type == "int" then
			if v.pointer and v.out then
				-- union.ptr = ints + <index>
				io.write("\tunion.ptr = ints + ", v.index, "\n")
			else
				-- union.i = arg
				io.write("\tunion.i = ", v.name, "\n")
			end

			-- ScriptHookV.nativePush64(union.value)
			io.write("\tScriptHookV.nativePush64(union.value)\n")
		-- Is boolean?
		elseif v.type == "BOOL" then
			-- union.b = arg
			io.write("\tunion.b = ", v.name, "\n")
			-- ScriptHookV.nativePush64(union.value)
			io.write("\tScriptHookV.nativePush64(union.value)\n")
		elseif v.type == "Vector3" and v.pointer then
			-- vectors[<index>] = arg
			io.write("\tvectors[", v.index, "] = ", v.name, "\n")
			-- union.ptr = vectors + <index>
			io.write("\tunion.ptr = vectors + ", v.index, "\n")
			-- ScriptHookV.nativePush64(union.value)
			io.write("\tScriptHookV.nativePush64(union.value)\n")
		else
			-- error("FIXME: <type> <name>")
			io.write("\terror(\"FIXME: ", v.type, " ", v.name, "\")\n")
			break
		end
	end

	-- Return value
	if ret == "void" or ret == "Void" then
		-- ScriptHookV.nativeCall()
		io.write("\tScriptHookV.nativeCall()")

		if #retVals > 0 then
			-- return
			io.write("\n\treturn ")
		end
	else
		-- union.value = ScriptHookV.nativeCall()[0]; [0] because it's pointer
		io.write("\tunion.value = ScriptHookV.nativeCall()[0]\n")
		-- return
		io.write("\treturn ")

		-- Is object type?
		if contains(objectType, ret) then
			-- (ffi.new("<type>", union.object.<type>))
			io.write("(ffi.new(\"", ret, "\", union.object.", ret:lower(), "))")
		-- Is string?
		elseif ret == "char*" then
			-- (ffi.string(union.ptr))
			io.write("\t(ffi.string(union.ptr))")
		-- Is float?
		elseif ret == "float" then
			-- union.f
			io.write("\tunion.f")
		-- Is int?
		elseif ret == "int" then
			-- return union.i
			io.write("union.i")
		-- Is boolean?
		elseif ret == "BOOL" then
			-- return union.i ~= 0
			io.write("union.i ~= 0")
		-- Is Vector3?
		elseif ret == "Vector3" then
			-- return (ffi.new("Vector3", ffi.cast("const Vector3*", union.ptr)))
			io.write("(ffi.new(\"Vector3\", ffi.cast(\"const Vector3*\", union.ptr)))")
		else
			-- FIXME: return <type>
			io.write("error(\"FIXME: return ", ret, "\")")
		end

		if #retVals > 0 then
			-- ,
			io.write(", ")
		end
	end

	-- Additional return types
	if #retVals > 0 then
		local finalRets = {}
		for i, v in ipairs(retVals) do
			if v.type == "int" then
				-- ints[<index>]
				finalRets[i] = "ints["..v.index.."]"
			elseif v.type == "float" then
				-- floats[<index>]
				finalRets[i] = "floats["..v.index.."]"
			else
				-- error("FIXME: return <type>")
				finalRets[i] = "error(\"FIXME: return "..v.type.."\")"
			end
		end

		io.write(table.concat(finalRets, ", "))
	end

	io.write("\nend\n\n")
end

-- Read definitions
local currentNamespace = nil
for line in natives:lines() do
	line = line:gsub("\r\n", ""):gsub("\n", ""):gsub("\r", "")

	if line:find("namespace", 1, true) == 1 then
		currentNamespace = line:sub(11)

		-- Decorate namespace
		local dups = string.rep("-", 13 + #currentNamespace + 3)
		io.write(dups, "\n")
		io.write("-- NAMESPACE ", currentNamespace, " --\n")
		io.write(dups, "\n")
		io.write(currentNamespace, " = {}\n")
	elseif currentNamespace then
		if line == "}" then
			currentNamespace = nil
			io.write("\n")
		elseif line ~= "{" then
			parseFunction(currentNamespace, line)
		end
	end
end
